
/*
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************

*/

#include <stdint.h>


#define RCC_BASE            0x40023800UL
#define RCC_AHB1ENR_OFFSET  0x30UL
#define RCC_CR_OFFSET       0x00UL
#define RCC_PLLCFGR_OFFSET  0x04UL
#define RCC_CFGR_OFFSET     0x08UL

#define GPIO_BASE           0x40020C00UL
#define GPIO_MODER_OFFSET   0x00UL
#define GPIO_ODR_OFFSET     0x14UL


void system_clk(void);
void delay(uint32_t count);

int main(void)
{
    system_clk();

    // Enable GPIOD clock
    *((volatile uint32_t *)(RCC_BASE + RCC_AHB1ENR_OFFSET)) |= (1UL << 3);

    // Configure GPIO D Pin 14 and Pin 15 as outputs
    *((volatile uint32_t *)(GPIO_BASE + GPIO_MODER_OFFSET)) &= ~(0x3UL << 28);
    *((volatile uint32_t *)(GPIO_BASE + GPIO_MODER_OFFSET)) |= (0x1UL << 28);

    *((volatile uint32_t *)(GPIO_BASE + GPIO_MODER_OFFSET)) &= ~(0x3UL << 30);
    *((volatile uint32_t *)(GPIO_BASE + GPIO_MODER_OFFSET)) |= (0x1UL << 30);


    while(1)
    {
        // Toggle GPIOD Pin 14 and Pin 15 (LEDs)
        *((volatile uint32_t *)(GPIO_BASE + GPIO_ODR_OFFSET)) ^= (0x3UL << 14);

        // Delay
        delay(1000000); // Adjust delay value for desired blinking speed
    }
}


void system_clk(void)
{
    // Enable HSE & wait for HSE to become ready
    *((volatile uint32_t *)(RCC_BASE + RCC_CR_OFFSET)) |= (1UL << 16);
    while (!(*((volatile uint32_t *)(RCC_BASE + RCC_CR_OFFSET)) & (1UL << 17)));

    // Configure flash prefetch and the latency related
    *((volatile uint32_t *)(0x40023C00UL + 0x00UL)) |= (1UL << 8) | (0x5UL << 0);

    // Configure PLL and Buses (AHB, APB1, APB2)
    // PLL Source: Here HSE is used as source
    *((volatile uint32_t *)(RCC_BASE + RCC_PLLCFGR_OFFSET)) |= (1UL << 22);

    // PLL Divider Settings (Assuming HSE is 8MHz, and we want 168MHz)
    *((volatile uint32_t *)(RCC_BASE + RCC_PLLCFGR_OFFSET)) |= (4UL << 0); // PLLM = 4
    *((volatile uint32_t *)(RCC_BASE + RCC_PLLCFGR_OFFSET)) |= (168UL << 6); // PLLN = 168
    *((volatile uint32_t *)(RCC_BASE + RCC_PLLCFGR_OFFSET)) |= (0UL << 16); // PLLP = 2 (Divide by 2)

    // Enable the PLL
    *((volatile uint32_t *)(RCC_BASE + RCC_CR_OFFSET)) |= (1UL << 24);
    while (!(*((volatile uint32_t *)(RCC_BASE + RCC_CR_OFFSET)) & (1UL << 25)));

    // Configure AHB, APB1, APB2 dividers
    *((volatile uint32_t *)(RCC_BASE + RCC_CFGR_OFFSET)) |= (0UL << 4);  // AHB Prescaler = 1
    *((volatile uint32_t *)(RCC_BASE + RCC_CFGR_OFFSET)) |= (0x4UL << 10); // APB1 Prescaler = 4 (42MHz)
    *((volatile uint32_t *)(RCC_BASE + RCC_CFGR_OFFSET)) |= (0x5UL << 13); // APB2 Prescaler = 2 (84MHz)

    // Set PLL as system clock source
    *((volatile uint32_t *)(RCC_BASE + RCC_CFGR_OFFSET)) |= (0x2UL << 0);
    while (!(*((volatile uint32_t *)(RCC_BASE + RCC_CFGR_OFFSET)) & (0x3UL << 2)));
}


void delay(uint32_t count)
{
    for (uint32_t i = 0; i < count; i++);
}

